#!/bin/sh

WAN=eth1
LAN=eth0
DEV=ifb0
DOWNLINK=200000 # in kbps
UPLINK=12000 # in kbps
QDISC=fq_codel
TC=tc
IP=ip
QUEUE_LENGTH=200 # in ms
EFLOWS=1024 # flow count as power of 2
IFLOWS=1024 # flow count as power of 2
EECN=ecn
IECN=ecn
INTERVAL=50 # in ms
RESOLUTION=1 # in ms
PACKET_SIZE=1514 # in bytes
BQL=$(( 4 * ${PACKET_SIZE} )) # in bytes
MIN_TARGET=5000 # in us
EQUANTUM=500 # in bytes
IQUANTUM=${PACKET_SIZE} # in bytes

flush_qdisc() {
    $TC qdisc del dev ${WAN} root 2> /dev/null
    $TC qdisc del dev ${WAN} handle ffff: ingress 2> /dev/null
    $TC qdisc del dev ${DEV} root 2> /dev/null
    $IP link set dev ${DEV} down 2> /dev/null
    $IP link delete ${DEV} type ifb 2> /dev/null
}

get_target() {
    # target computation based on packet size (mtu).
    TARGET=$(( ${PACKET_SIZE} * 8 * 1000 / ${1} ))
    [ ${TARGET} -lt ${MIN_TARGET} ] && TARGET=${MIN_TARGET}
    echo ${TARGET}us
}

get_buffer() {
    BUFFER=$(( ( ${RESOLUTION} * ${1} * 1000 / ( 1000 * 8 ) ) + 1 ))
    [ ${BUFFER} -lt $(( ${PACKET_SIZE} + 1 )) ] && BUFFER=$(( ${PACKET_SIZE} + 1 ))
    echo ${BUFFER}B
}

get_limit() {
    LIMIT=$(( ${QUEUE_LENGTH} * ${1} / ( ${PACKET_SIZE} * 8 ) ))
    echo ${LIMIT}
}

eth_setup() {
    # turn offloads off.
    ethtool -K ${1} gso off 2> /dev/null
    ethtool -K ${1} tso off 2> /dev/null
    ethtool -K ${1} ufo off 2> /dev/null
    ethtool -K ${1} gro off 2> /dev/null

    # setup BQL.
    if [ -e /sys/class/net/${1}/queues/tx-0/byte_queue_limits ]
    then
       for i in /sys/class/net/${1}/queues/tx-*/byte_queue_limits
       do
          echo ${BQL} > $i/limit_max
       done
    fi
}

egress_qdisc() {
    $TC qdisc del dev ${WAN} root 2> /dev/null
    $TC qdisc add dev ${WAN} root handle 1: tbf rate ${UPLINK}kbit \
        buffer `get_buffer ${UPLINK}` latency ${QUEUE_LENGTH}ms

    $TC qdisc add dev ${WAN} parent 1: handle 11: ${QDISC} \
        target `get_target ${UPLINK}` limit `get_limit ${UPLINK}` ${EECN} flows ${EFLOWS} \
        quantum ${EQUANTUM} interval ${INTERVAL}ms
}

ingress_qdisc() {
    $TC qdisc del dev ${WAN} handle ffff: ingress 2> /dev/null
    $TC qdisc add dev ${WAN} handle ffff: ingress

    $IP link add name ${DEV} type ifb

    $TC qdisc del dev ${DEV} root 2> /dev/null
    $TC qdisc add dev ${DEV} root handle 1: tbf rate ${DOWNLINK}kbit \
        buffer `get_buffer ${DOWNLINK}` latency ${QUEUE_LENGTH}ms

    $TC qdisc add dev ${DEV} parent 1: handle 11: ${QDISC} \
        target `get_target ${DOWNLINK}` limit `get_limit ${DOWNLINK}` ${IECN} flows ${IFLOWS} \
        quantum ${IQUANTUM} interval ${INTERVAL}ms

    $IP link set dev ${DEV} up

    $TC filter add dev ${WAN} parent ffff: protocol all prio 1 u32 \
    match u32 0 0 action mirred egress redirect dev ${DEV}
}

tc_start() {
    flush_qdisc
    eth_setup ${WAN}
    eth_setup ${LAN}
    egress_qdisc
    ingress_qdisc
}

tc_stop() {
    flush_qdisc
}

case "$1" in
start|restart|reload|force-reload)
    tc_start
    ;;
save)
    echo "tc save not applicable."
    ;;
stop)
    echo "Automatic flushing disabled, use \"flush\" instead of \"stop\""
    ;;
flush)
    tc_stop
    ;;
*)
    echo "Usage: $0 {start|restart|reload|force-reload|save|flush}" >&2
    exit 1
    ;;
esac

exit 0
